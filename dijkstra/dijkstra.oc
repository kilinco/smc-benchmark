#include <stdio.h>
#include <stdlib.h>
#include <obliv.oh>

#include "dijkstra.h"
#include "dbg.h"

void revealClientArr(protocolIO *io, obliv int *oa, int party){
	revealOblivIntArray(io->arr, oa, V, 0);
	for(int i = 0; i < V; i++)
		printf("Party %d Element %d revealed as %d\n", ocCurrentParty(), i, io->arr[i]);
}

void dijkstra_algo(protocolIO *io, obliv int *oa, obliv int *dist){
	bool *visited = (bool *)malloc(sizeof(bool) * V);
	for(int i = 0; i < V; i ++) visited[i] = false;
	obliv int max = INT_MAX;
	obliv int min = 0;
	//revealClientArr(io, dist, 0);

	for(int count = 0; count < V; count++){
		int v;
		for(v = 0; v < V; v++){
			if(visited[v] == false){ 
				break;
			}
		}
		printf("v = %d\n",v);
		visited[v] = true; 
		for (int i = 0; i < V; i++){
				obliv if(oa[v*V+i] !=  min)
					obliv if(dist[v] != max)
						obliv if(dist[v] + oa[v*V+i] < dist[i]) 
							dist[i] = dist[v] + oa[v*V+i]; 
		} 
	} 
	free(visited);
}

void dijkstra(void* args){
	protocolIO *io = (protocolIO*) args;

	int *x = malloc(sizeof(int) * ALLOC);
	int *y = malloc(sizeof(int) * ALLOC);
	load_dummy(io, &x, &y, ocCurrentParty());

	printf("Dummy Loaded!\n");
	obliv int *ox = malloc(sizeof(obliv int) * io->n);
	obliv int *oy = malloc(sizeof(obliv int) * io->n);
	printf("Obliv Data Allocated!\n");

	feedOblivIntArray(ox, x, io->n, 1);
	feedOblivIntArray(oy, y, io->n, 2);
	free(x);
	free(y);

	printf("Initializing output for party %d!\n", ocCurrentParty());
	io->arr = malloc(sizeof(int) * V);
	obliv int *dist = malloc(sizeof(obliv int) * V);
	
	io->arr[0]=0;
	for(int i = 1; i < V; i++) io->arr[i] = INT_MAX;
	feedOblivIntArray(dist, io->arr, V, 1);
	dijkstra_algo(io, ox, dist);
	revealOblivIntArray(io->arr, dist, V, 0);
	
	printf("Client Data Revealed!\n");
	free(ox);
	free(oy);
	free(dist);
	printf("Obliv Data Freed!\n");
	log_info("Yao Gate Count: %d\n", yaoGateCount());
}

